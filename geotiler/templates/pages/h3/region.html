<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>H3 {{ title }}</title>

<!-- MapLibre GL JS -->
<link href="https://unpkg.com/maplibre-gl@^4.0.0/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@^4.0.0/dist/maplibre-gl.js"></script>

<!-- deck.gl standalone -->
<script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"></script>

<!-- h3-js for hex geometry conversion -->
<script src="https://unpkg.com/h3-js@^4.0.0/dist/h3-js.umd.js"></script>

<!-- TopoJSON client for country boundary decoding -->
<script src="https://unpkg.com/topojson-client@3/dist/topojson-client.min.js"></script>

<style>
*, *::before, *::after { box-sizing: border-box; }
body { margin: 0; }

.h3-explorer {
    position: relative; height: 100vh; padding: 0; max-width: none;
    background: #0a0a14; color: #d0d0d0; overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
}
#h3-map { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

/* ---- Controls ---- */
#h3-controls {
    position: absolute; top: 12px; left: 12px; z-index: 10;
    background: rgba(30, 32, 48, 0.92); backdrop-filter: blur(16px);
    border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5); border-radius: 10px;
    padding: 14px 18px; display: flex; gap: 14px; align-items: flex-end; flex-wrap: wrap;
    max-width: calc(100vw - 24px);
}
.h3-cg { display: flex; flex-direction: column; gap: 4px; }
.h3-cg label {
    font-size: 14px; text-transform: uppercase; letter-spacing: 0.8px;
    color: #aaa; font-weight: 600;
}
.h3-cg select {
    background: rgba(255,255,255,0.10); color: #fff;
    border: 1px solid rgba(255,255,255,0.20); border-radius: 6px;
    padding: 7px 30px 7px 10px; font-size: 13px; cursor: pointer;
    color-scheme: dark; appearance: none; -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23aaa'/%3E%3C/svg%3E");
    background-repeat: no-repeat; background-position: right 8px center;
}
.h3-cg select option { background: #1a1a2e; color: #eee; }
.h3-cg select:hover { border-color: rgba(255,255,255,0.35); }
.h3-cg select:focus { outline: none; border-color: #64acbe; }
.h3-cg.dimmed { opacity: 0.35; pointer-events: none; }

.h3-export-btn {
    display: flex; align-items: center; gap: 5px; align-self: flex-end;
    background: rgba(255,255,255,0.08); color: #b0b0b0;
    border: 1px solid rgba(255,255,255,0.18); border-radius: 6px;
    padding: 7px 12px; font-size: 12px; font-weight: 600; cursor: pointer;
    letter-spacing: 0.5px; transition: all 0.15s; white-space: nowrap;
}
.h3-export-btn:hover { background: rgba(255,255,255,0.14); color: #e0e0e0; border-color: rgba(255,255,255,0.3); }
.h3-export-btn:active { transform: scale(0.97); }
.h3-export-btn:disabled { opacity: 0.4; cursor: default; transform: none; }

.h3-toggle-btn {
    display: flex; align-items: center; gap: 5px; align-self: flex-end;
    background: rgba(255,255,255,0.08); color: #b0b0b0;
    border: 1px solid rgba(255,255,255,0.18); border-radius: 6px;
    padding: 7px 12px; font-size: 12px; font-weight: 600; cursor: pointer;
    letter-spacing: 0.5px; transition: all 0.15s; white-space: nowrap;
}
.h3-toggle-btn:hover { background: rgba(255,255,255,0.14); color: #e0e0e0; border-color: rgba(255,255,255,0.3); }
.h3-toggle-btn.active {
    background: rgba(40, 120, 200, 0.25); color: #6cb8ff;
    border-color: rgba(100, 160, 255, 0.5);
    box-shadow: 0 0 8px rgba(80, 140, 255, 0.25);
}

/* ---- View Tabs ---- */
.h3-view-tabs {
    display: flex; gap: 2px; background: rgba(255,255,255,0.04);
    border-radius: 6px; padding: 2px; align-self: flex-end;
}
.h3-view-tab {
    background: none; border: none; color: #a0a0a0; font-size: 12px; font-weight: 600;
    padding: 6px 12px; border-radius: 5px; cursor: pointer; white-space: nowrap;
    transition: all 0.15s;
}
.h3-view-tab:hover { color: #bbb; }
.h3-view-tab.active { background: rgba(255,255,255,0.1); color: #e0e0e0; }

#h3-status {
    font-size: 11px; color: #a0a0a0; padding: 6px 0; min-width: 120px; text-align: right;
}

/* ---- Legend ---- */
#h3-legend {
    position: absolute; bottom: 32px; left: 12px; z-index: 10;
    background: rgba(30, 32, 48, 0.92); backdrop-filter: blur(16px);
    border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5); border-radius: 10px;
    padding: 14px 16px;
}
.h3-legend-title { font-size: 12px; font-weight: 600; margin-bottom: 8px; color: #b0b0b0; }
.h3-legend-body { display: flex; gap: 8px; align-items: flex-end; }
.h3-legend-ylabel {
    writing-mode: vertical-lr; transform: rotate(180deg);
    font-size: 11px; color: #a0a0a0; text-align: center; letter-spacing: 0.5px;
}
.h3-legend-grid-wrap { display: flex; flex-direction: column; align-items: center; }
.h3-legend-grid {
    display: grid; grid-template-columns: repeat(5, 24px); grid-template-rows: repeat(5, 24px);
    gap: 1px;
}
.h3-legend-cell { border-radius: 2px; }
.h3-legend-ticks { display: flex; justify-content: space-between; width: 100%; }
.h3-legend-ticks span { font-size: 10px; color: #888; }

/* Quad legend */
.h3-quad-legend { display: flex; flex-direction: column; gap: 10px; }
.h3-quad-zone-label { font-size: 12px; font-weight: 600; margin-bottom: 3px; }
.h3-quad-zone-label.safe { color: #2ab873; }
.h3-quad-zone-label.risk { color: #e63946; }
.h3-quad-ramps { display: flex; gap: 12px; }
.h3-quad-ramp-wrap { display: flex; flex-direction: column; gap: 2px; }
.h3-quad-ramp {
    display: flex; gap: 1px; height: 16px; border-radius: 3px; overflow: hidden;
}
.h3-quad-ramp-cell { flex: 1; min-width: 20px; }
.h3-quad-ramp-label { font-size: 10px; color: #999; text-align: center; }
.h3-quad-prod-labels { display: flex; justify-content: space-between; margin-top: 2px; }
.h3-quad-prod-labels span { font-size: 10px; color: #888; }

/* ---- Stats ---- */
#h3-stats {
    position: absolute; bottom: 32px; right: 12px; z-index: 10;
    background: rgba(30, 32, 48, 0.92); backdrop-filter: blur(16px);
    border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5); border-radius: 10px;
    padding: 12px 16px; min-width: 180px;
}
.h3-stat-row { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 4px; }
.h3-stat-label { font-size: 12px; color: #a0a0a0; text-transform: uppercase; letter-spacing: 0.5px; }
.h3-stat-value {
    font-size: 13px; font-weight: 600;
    font-family: 'SF Mono', 'Menlo', 'Consolas', 'Monaco', monospace;
    font-variant-numeric: tabular-nums; text-align: right;
}
.h3-stat-value.warning { color: #c85a5a; }

/* ---- Tooltip ---- */
#h3-tooltip {
    display: none; position: absolute; z-index: 20; pointer-events: none;
    background: rgba(8, 8, 16, 0.92); backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;
    padding: 10px 14px; font-size: 12px; line-height: 1.5;
    max-width: 280px; color: #d0d0d0;
}
#h3-tooltip strong { color: #fff; }
#h3-tooltip .tt-row { display: flex; justify-content: space-between; gap: 14px; }
#h3-tooltip .tt-lbl { white-space: nowrap; }
#h3-tooltip .tt-val {
    color: #64acbe; font-weight: 600; text-align: right; white-space: nowrap;
    font-family: 'SF Mono', 'Menlo', 'Consolas', 'Monaco', monospace;
    font-variant-numeric: tabular-nums;
}
#h3-tooltip .spei-val {
    font-weight: 600; text-align: right; white-space: nowrap;
    font-family: 'SF Mono', 'Menlo', 'Consolas', 'Monaco', monospace;
    font-variant-numeric: tabular-nums;
}
.spei-wet { color: #64acbe; }
.spei-mod { color: #e4acac; }
.spei-dry { color: #c85a5a; }

/* ---- Loading ---- */
#h3-loading {
    position: absolute; inset: 0; z-index: 100;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: rgba(6, 6, 14, 0.95); transition: opacity 0.3s;
}
#h3-loading.hidden { opacity: 0; pointer-events: none; }
.h3-spinner {
    width: 36px; height: 36px; border: 3px solid rgba(255,255,255,0.1);
    border-top-color: #64acbe; border-radius: 50%;
    animation: h3spin 0.8s linear infinite; margin-bottom: 12px;
}
@keyframes h3spin { to { transform: rotate(360deg); } }
.h3-loading-text { font-size: 13px; color: #a0a0a0; }
.maplibregl-ctrl-attrib { font-size: 10px !important; }
</style>
</head>

<body class="h3-explorer">
<div id="h3-map"></div>

<div id="h3-controls">
    <div class="h3-cg">
        <label>View</label>
        <div class="h3-view-tabs">
            <button class="h3-view-tab active" data-view="production">Production</button>
            <button class="h3-view-tab" data-view="tech-biv" style="display:none">Irrig vs Rain</button>
            <button class="h3-view-tab" data-view="bivariate">SPEI Bivariate</button>
            <button class="h3-view-tab" data-view="quad">Tech Split</button>
        </div>
    </div>
    <div class="h3-cg">
        <label>Crop</label>
        <select id="sel-crop"></select>
    </div>
    <div class="h3-cg" id="cg-tech">
        <label>Technology</label>
        <select id="sel-tech">
            <option value="a">All</option>
            <option value="i">Irrigated</option>
            <option value="r">Rainfed</option>
        </select>
    </div>
    <div class="h3-cg">
        <label>SPEI-12 Drought Scenario</label>
        <select id="sel-scenario">
            <optgroup label="Observed (ERA5 Reanalysis)">
                <option value="spei12_era5_2024_mean">2024 &mdash; Annual Mean</option>
                <option value="spei12_era5_2024_min">2024 &mdash; Worst Month</option>
                <option value="spei12_era5_2023_mean">2023 &mdash; Annual Mean</option>
                <option value="spei12_era5_2023_min">2023 &mdash; Worst Month</option>
                <option value="spei12_era5_2022_mean">2022 &mdash; Annual Mean</option>
                <option value="spei12_era5_2022_min">2022 &mdash; Worst Month</option>
            </optgroup>
            <optgroup label="Projected 2050 (CMIP6)">
                <option value="spei12_ssp585_median" selected>SSP5-8.5 &mdash; Median</option>
                <option value="spei12_ssp585_p10">SSP5-8.5 &mdash; 10th Percentile (Driest)</option>
                <option value="spei12_ssp370_median">SSP3-7.0 &mdash; Median</option>
                <option value="spei12_ssp370_p10">SSP3-7.0 &mdash; 10th Percentile (Driest)</option>
            </optgroup>
        </select>
    </div>
    <div class="h3-cg">
        <label>Drought Threshold</label>
        <select id="sel-threshold">
            <option value="-1">SPEI &lt; -1.0 (Moderate)</option>
            <option value="-1.5" selected>SPEI &lt; -1.5 (Severe)</option>
            <option value="-2">SPEI &lt; -2.0 (Extreme)</option>
        </select>
    </div>
    <div class="h3-cg" id="cg-palette">
        <label>Palette</label>
        <select id="sel-palette"></select>
    </div>
    <button id="btn-export" class="h3-export-btn" title="Export map as PNG">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round">
            <path d="M8 2v8M4.5 7L8 10.5 11.5 7M3 13h10"/>
        </svg>
        PNG
    </button>
    <div id="h3-status">Initializing...</div>
</div>

<div id="h3-legend"></div>

<div id="h3-stats">
    <div class="h3-stat-row">
        <span class="h3-stat-label">Harvested Area</span>
        <span class="h3-stat-value" id="stat-area">-</span>
    </div>
    <div class="h3-stat-row">
        <span class="h3-stat-label">Area at Risk</span>
        <span class="h3-stat-value warning" id="stat-area-risk">-</span>
    </div>
    <div class="h3-stat-row">
        <span class="h3-stat-label">Production</span>
        <span class="h3-stat-value" id="stat-prod">-</span>
    </div>
    <div class="h3-stat-row">
        <span class="h3-stat-label">Production at Risk</span>
        <span class="h3-stat-value warning" id="stat-risk">-</span>
    </div>
</div>

<div id="h3-tooltip"></div>

<div id="h3-loading">
    <div class="h3-spinner"></div>
    <div class="h3-loading-text" id="h3-loading-text">Initializing...</div>
</div>
<script type="module">

// ============================================================
// Configuration
// ============================================================

const SERVER_SIDE = {{ 'true' if h3_server_side else 'false' }};

const CROPS = [
    {code:'bana',name:'Banana'},{code:'barl',name:'Barley'},{code:'bean',name:'Bean'},
    {code:'cass',name:'Cassava'},{code:'chic',name:'Chickpea'},{code:'citr',name:'Citrus'},
    {code:'cnut',name:'Coconut'},{code:'coco',name:'Cocoa'},{code:'coff',name:'Arabica Coffee'},
    {code:'cott',name:'Cotton'},{code:'cowp',name:'Cowpea'},{code:'grou',name:'Groundnut'},
    {code:'lent',name:'Lentil'},{code:'maiz',name:'Maize'},{code:'mill',name:'Millet (Small)'},
    {code:'ocer',name:'Other Cereals'},{code:'ofib',name:'Other Fibre'},{code:'oilp',name:'Oil Palm'},
    {code:'onio',name:'Onion'},{code:'ooil',name:'Other Oils'},{code:'opul',name:'Other Pulses'},
    {code:'orts',name:'Other Roots'},{code:'pige',name:'Pigeonpea'},{code:'plnt',name:'Plantain'},
    {code:'pmil',name:'Pearl Millet'},{code:'pota',name:'Potato'},{code:'rape',name:'Rapeseed'},
    {code:'rcof',name:'Robusta Coffee'},{code:'rest',name:'Rest of Crops'},{code:'rice',name:'Rice'},
    {code:'rubb',name:'Rubber'},{code:'sesa',name:'Sesame'},{code:'sorg',name:'Sorghum'},
    {code:'soyb',name:'Soybean'},{code:'sugb',name:'Sugar Beet'},{code:'sugc',name:'Sugarcane'},
    {code:'sunf',name:'Sunflower'},{code:'swpo',name:'Sweet Potato'},{code:'teas',name:'Tea'},
    {code:'temf',name:'Temperate Fruit'},{code:'toba',name:'Tobacco'},{code:'toma',name:'Tomato'},
    {code:'trof',name:'Tropical Fruit'},{code:'vege',name:'Vegetables'},{code:'whea',name:'Wheat'},
    {code:'yams',name:'Yams'},
];

// Bivariate palettes (SPEI continuous view)
const PALETTES = {
    fire: {
        name: 'Fire Alert',
        safe:    [[230,245,230], [155,220,175], [50,190,110],  [0,160,60],   [0,120,40]],
        drought: [[255,210,200], [255,145,120], [255,70,60],   [230,20,40],  [180,0,30]],
    },
    emergency: {
        name: 'Emergency Red',
        safe:    [[230,235,245], [170,198,225], [95,155,200],  [35,115,175], [0,75,145]],
        drought: [[250,210,200], [245,160,140], [235,100,85],  [220,50,40],  [180,20,20]],
    },
    stevens: {
        name: 'Classic (Stevens)',
        safe:    [[255,255,215], [250,225,135], [240,185,55], [200,145,15], [150,100,0]],
        drought: [[254,210,200], [252,154,120], [239,83,80], [203,24,29], [128,0,13]],
    },
    neon: {
        name: 'Neon Danger',
        safe:    [[235,245,250], [170,218,230], [80,190,210],  [15,155,185], [0,120,155]],
        drought: [[255,230,180], [255,190,100], [255,155,30],  [255,120,0],  [230,90,0]],
    },
    violet: {
        name: 'Violet Heat',
        safe:    [[230,245,230], [155,220,175], [60,195,120],  [0,165,65],   [0,125,40]],
        drought: [[240,200,230], [225,140,200], [210,80,175],  [195,30,155], [170,0,130]],
    },
    solar: {
        name: 'Solar Flare',
        safe:    [[235,240,248], [180,208,230], [110,172,210], [50,138,185], [10,100,158]],
        drought: [[255,225,195], [255,180,120], [255,130,55],  [245,85,25],  [220,55,0]],
    },
    stoplight: {
        name: 'Stoplight',
        safe:    [[230,245,230], [165,225,165], [80,200,100],  [20,170,50],  [0,130,20]],
        drought: [[255,235,195], [255,200,120], [255,155,50],  [240,90,30], [215,40,15]],
    },
};

// Production-only ramp (amber/gold on dark basemap)
const PROD_RAMP = [[235,230,210], [215,195,120], [190,160,45], [160,120,10], [125,85,0]];

// Tech bivariate: 4-corner bilinear interpolation
// Production drives light→dark, rainfed share drives hue
const TECH_BIV_CORNERS = {
    BL: [238, 245, 235],  // light green tint (low prod, irrigated)
    BR: [0, 105, 20],     // dark green       (high prod, irrigated)
    TL: [225, 235, 250],  // light blue tint  (low prod, rainfed)
    TR: [145, 118, 0],    // dark yellow      (high prod, rainfed)
};

// Quad-view: 4 fixed ramps (green / blue / orange / red)
const QUAD = {
    safe_irrig:    [[210,238,210], [150,210,150], [80,178,80],  [25,145,40],  [0,105,20]],
    safe_rain:     [[210,225,248], [150,192,232], [82,152,212], [28,112,182], [0,72,142]],
    drought_irrig: [[255,228,188], [255,192,132], [252,152,62], [238,112,18], [202,82,0]],
    drought_rain:  [[252,208,202], [242,158,142], [228,98,82],  [205,48,38],  [168,18,18]],
};

let currentPalette = 'fire';
let currentView = 'production';

const SPEI_WET = 0;
const SPEI_DRY = -2.5;
let DROUGHT_SPEI_THRESHOLD = -1.5;

// ============================================================
// Region Country Filter
// ============================================================

const REGION_CODES = new Set({{ country_codes | tojson }});
const EXCLUDE_CODES = new Set({{ exclude_codes | tojson }});

// ============================================================
// State
// ============================================================

let map = null;
let deckOverlay = null;
let currentData = [];
let queryInFlight = false;
let currentCropName = 'Wheat';
const queryCache = new Map();

let borderGeoJSON = null;
let regionPolygons = [];
const regionHexCache = new Map();

// ============================================================
// Country Boundary Loading
// ============================================================

async function loadBoundaries() {
    const resp = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
    if (!resp.ok) throw new Error(`Failed to load boundaries: ${resp.status}`);
    const world = await resp.json();
    const allCountries = topojson.feature(world, world.objects.countries);

    borderGeoJSON = {
        type: 'FeatureCollection',
        features: allCountries.features.filter(f => !EXCLUDE_CODES.has(String(f.id).padStart(3, '0'))),
    };

    const regionFeatures = allCountries.features.filter(f => REGION_CODES.has(String(f.id).padStart(3, '0')));
    regionPolygons = extractPolygons(regionFeatures);
}

function extractPolygons(features) {
    const result = [];
    for (const feature of features) {
        const geom = feature.geometry;
        const groups = geom.type === 'Polygon' ? [geom.coordinates]
            : geom.type === 'MultiPolygon' ? geom.coordinates : [];
        for (const rings of groups) {
            const outer = rings[0], holes = rings.slice(1);
            let minLng = Infinity, maxLng = -Infinity, minLat = Infinity, maxLat = -Infinity;
            for (const [lng, lat] of outer) {
                if (lng < minLng) minLng = lng; if (lng > maxLng) maxLng = lng;
                if (lat < minLat) minLat = lat; if (lat > maxLat) maxLat = lat;
            }
            result.push({ outer, holes, bbox: [minLng, minLat, maxLng, maxLat] });
        }
    }
    return result;
}

// ============================================================
// Point-in-Polygon
// ============================================================

function pointInRing(x, y, ring) {
    let inside = false;
    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const [xi, yi] = ring[i], [xj, yj] = ring[j];
        if ((yi > y) !== (yj > y) && x < (xj - xi) * (y - yi) / (yj - yi) + xi)
            inside = !inside;
    }
    return inside;
}

function isInRegion(lng, lat) {
    for (const poly of regionPolygons) {
        const [a, b, c, d] = poly.bbox;
        if (lng < a || lng > c || lat < b || lat > d) continue;
        if (!pointInRing(lng, lat, poly.outer)) continue;
        let inHole = false;
        for (const hole of poly.holes) { if (pointInRing(lng, lat, hole)) { inHole = true; break; } }
        if (!inHole) return true;
    }
    return false;
}

function filterRegion(data) {
    if (!regionPolygons.length) return data;
    return data.filter(d => {
        const cached = regionHexCache.get(d.h3_index);
        if (cached !== undefined) return cached;
        const [lat, lng] = h3.cellToLatLng(d.h3_index);
        const inside = isInRegion(lng, lat);
        regionHexCache.set(d.h3_index, inside);
        return inside;
    });
}

// ============================================================
// Data Query
// ============================================================

async function queryData(crop, tech, scenario) {
    const cacheKey = `${crop}_${tech}_${scenario}`;
    const cached = queryCache.get(cacheKey);
    if (cached) return { data: cached, fromCache: true };

    const params = new URLSearchParams({crop, tech, scenario});
    const resp = await fetch(`/h3/query?${params}`);
    if (!resp.ok) {
        const err = await resp.json().catch(() => ({}));
        throw new Error(err.error || `Query failed (${resp.status})`);
    }
    const result = await resp.json();
    queryCache.set(cacheKey, result.data);
    return { data: result.data, fromCache: false };
}

// Fetch both irrigated + rainfed and merge by h3_index
async function queryBothTechs(crop, scenario) {
    const [iRes, rRes] = await Promise.all([
        queryData(crop, 'i', scenario),
        queryData(crop, 'r', scenario),
    ]);

    const merged = new Map();
    for (const d of iRes.data) {
        merged.set(d.h3_index, {
            h3_index: d.h3_index, i_prod: d.production, r_prod: 0,
            i_area: d.harv_area_ha, r_area: 0, spei: d.spei,
        });
    }
    for (const d of rRes.data) {
        const m = merged.get(d.h3_index);
        if (m) { m.r_prod = d.production; m.r_area = d.harv_area_ha; }
        else {
            merged.set(d.h3_index, {
                h3_index: d.h3_index, i_prod: 0, r_prod: d.production,
                i_area: 0, r_area: d.harv_area_ha, spei: d.spei,
            });
        }
    }

    const data = [];
    for (const d of merged.values()) {
        d.production = d.i_prod + d.r_prod;
        d.harv_area_ha = d.i_area + d.r_area;
        d.rainfed_pct = d.production > 0 ? d.r_prod / d.production : 0;
        data.push(d);
    }
    return { data, fromCache: iRes.fromCache && rRes.fromCache };
}

// ============================================================
// Classification & Color
// ============================================================

function log10Breaks(values, nBins) {
    let minVal = Infinity, maxVal = -Infinity;
    for (const v of values) {
        if (v > 0) { if (v < minVal) minVal = v; if (v > maxVal) maxVal = v; }
    }
    if (minVal >= maxVal) return Array(nBins - 1).fill(maxVal);
    const logMin = Math.log10(minVal), logMax = Math.log10(maxVal);
    const step = (logMax - logMin) / nBins;
    const breaks = [];
    for (let i = 1; i < nBins; i++) breaks.push(Math.pow(10, logMin + step * i));
    return breaks;
}

function classifyLog(val, breaks) {
    for (let i = 0; i < breaks.length; i++) { if (val <= breaks[i]) return i; }
    return breaks.length;
}

function speiToT(spei) {
    if (spei == null) return 0.5;
    if (spei >= SPEI_WET) return 0;
    if (spei <= SPEI_DRY) return 1;
    return (SPEI_WET - spei) / (SPEI_WET - SPEI_DRY);
}

function lerpColor(c1, c2, t) {
    return [
        Math.round(c1[0] + (c2[0] - c1[0]) * t),
        Math.round(c1[1] + (c2[1] - c1[1]) * t),
        Math.round(c1[2] + (c2[2] - c1[2]) * t),
    ];
}

function productionColor(prodBin) {
    return [...PROD_RAMP[prodBin], 200];
}

function techBivColor(prodBin, rainfedPct) {
    // Bilinear interpolation across 4 corners
    const tx = prodBin / 4;  // production: 0→1
    const ty = rainfedPct;   // rainfed share: 0→1
    const {BL, BR, TL, TR} = TECH_BIV_CORNERS;
    return [
        Math.round((1-tx)*(1-ty)*BL[0] + tx*(1-ty)*BR[0] + (1-tx)*ty*TL[0] + tx*ty*TR[0]),
        Math.round((1-tx)*(1-ty)*BL[1] + tx*(1-ty)*BR[1] + (1-tx)*ty*TL[1] + tx*ty*TR[1]),
        Math.round((1-tx)*(1-ty)*BL[2] + tx*(1-ty)*BR[2] + (1-tx)*ty*TL[2] + tx*ty*TR[2]),
        200,
    ];
}

function bivariateColor(prodBin, spei) {
    const pal = PALETTES[currentPalette];
    const t = speiToT(spei);
    return [...lerpColor(pal.safe[prodBin], pal.drought[prodBin], t), 200];
}

function quadColor(prodBin, rainfedPct, isDrought) {
    const irrig = isDrought ? QUAD.drought_irrig : QUAD.safe_irrig;
    const rain  = isDrought ? QUAD.drought_rain  : QUAD.safe_rain;
    return [...lerpColor(irrig[prodBin], rain[prodBin], rainfedPct), 200];
}

// ============================================================
// Map Initialization
// ============================================================

function initMap() {
    map = new maplibregl.Map({
        container: 'h3-map',
        style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
        center: {{ center | tojson }}, zoom: {{ zoom }}, maxZoom: 14, antialias: true,
        preserveDrawingBuffer: true,
    });
    map.addControl(new maplibregl.NavigationControl(), 'top-right');
    map.addControl(new maplibregl.ScaleControl({maxWidth: 150}), 'bottom-right');
    deckOverlay = new deck.MapboxOverlay({interleaved: false, layers: []});
    map.addControl(deckOverlay);
}

// ============================================================
// Layer Rendering
// ============================================================

function buildLayers(data) {
    const layers = [];

    if (data.length) {
        const prodValues = data.map(d => d.production).filter(v => v > 0);
        const breaks = log10Breaks(prodValues, 5);

        const processed = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            const d = data[i];
            const boundary = h3.cellToBoundary(d.h3_index);
            const polygon = boundary.map(([lat, lng]) => [lng, lat]);
            polygon.push(polygon[0]);
            const prodBin = classifyLog(d.production, breaks);

            let color;
            if (currentView === 'production') {
                color = productionColor(prodBin);
            } else if (currentView === 'tech-biv') {
                color = techBivColor(prodBin, d.rainfed_pct || 0);
            } else if (currentView === 'quad') {
                const isDrought = d.spei != null && d.spei < DROUGHT_SPEI_THRESHOLD;
                color = quadColor(prodBin, d.rainfed_pct || 0, isDrought);
            } else {
                color = bivariateColor(prodBin, d.spei);
            }

            processed[i] = {
                polygon, h3_index: d.h3_index,
                production: d.production, harv_area_ha: d.harv_area_ha, spei: d.spei,
                i_prod: d.i_prod, r_prod: d.r_prod, rainfed_pct: d.rainfed_pct,
                prodBin, color,
            };
        }

        layers.push(new deck.PolygonLayer({
            id: 'h3-layer', data: processed,
            getPolygon: d => d.polygon, getFillColor: d => d.color,
            getLineColor: [255, 255, 255, 20], getLineWidth: 1,
            lineWidthMinPixels: 0.3, lineWidthMaxPixels: 1,
            pickable: true, autoHighlight: true, highlightColor: [255, 255, 255, 60],
            onHover: onHover, parameters: {depthTest: false},
            transitions: {getFillColor: 400},
        }));
    }

    if (borderGeoJSON) {
        layers.push(new deck.GeoJsonLayer({
            id: 'country-borders', data: borderGeoJSON,
            stroked: true, filled: false,
            getLineColor: [220, 220, 230, 70], getLineWidth: 1,
            lineWidthMinPixels: 0.5, lineWidthMaxPixels: 2,
            parameters: {depthTest: false},
        }));
    }

    deckOverlay.setProps({layers});
}

// ============================================================
// Tooltip
// ============================================================

const tooltip = document.getElementById('h3-tooltip');

function onHover({object, x, y}) {
    if (!object) { tooltip.style.display = 'none'; return; }

    const speiClass = object.spei == null ? '' :
        object.spei > 0 ? 'spei-wet' : object.spei >= -1 ? 'spei-mod' : 'spei-dry';
    const speiLabel = object.spei == null ? 'N/A' : object.spei.toFixed(3);

    let html = `<strong>${currentCropName}</strong>`;

    if (currentView !== 'production' && object.i_prod != null) {
        const iPct = object.production > 0 ? (object.i_prod / object.production * 100).toFixed(0) : 0;
        const rPct = object.production > 0 ? (object.r_prod / object.production * 100).toFixed(0) : 0;
        html += `<div class="tt-row"><span class="tt-lbl">Irrigated</span><span class="tt-val">${formatMT(object.i_prod)} (${iPct}%)</span></div>`;
        html += `<div class="tt-row"><span class="tt-lbl">Rainfed</span><span class="tt-val">${formatMT(object.r_prod)} (${rPct}%)</span></div>`;
        html += `<div class="tt-row"><span class="tt-lbl">Total</span><span class="tt-val">${formatMT(object.production)}</span></div>`;
    } else {
        html += `<div class="tt-row"><span class="tt-lbl">Production</span><span class="tt-val">${formatMT(object.production)}</span></div>`;
    }

    html += `<div class="tt-row"><span class="tt-lbl">Harvested</span><span class="tt-val">${formatHA(object.harv_area_ha)}</span></div>`;
    html += `<div class="tt-row"><span class="tt-lbl">SPEI-12</span><span class="spei-val ${speiClass}">${speiLabel}</span></div>`;

    tooltip.innerHTML = html;
    tooltip.style.display = 'block';
    tooltip.style.left = `${x + 14}px`;
    tooltip.style.top = `${y + 14}px`;
}

function formatMT(val) {
    if (val >= 1e6) return (val / 1e6).toFixed(1) + ' M MT';
    if (val >= 1e3) return (val / 1e3).toFixed(1) + ' K MT';
    return val.toFixed(0) + ' MT';
}

function formatHA(ha) {
    if (ha >= 1e6) return (ha / 1e6).toFixed(2) + ' M ha';
    if (ha >= 1e3) return (ha / 1e3).toFixed(1) + ' K ha';
    return ha.toFixed(0) + ' ha';
}

// ============================================================
// Stats Panel
// ============================================================

function updateStats(data) {
    let totalArea = 0, totalProd = 0, riskArea = 0, riskProd = 0;
    for (const d of data) {
        totalArea += d.harv_area_ha;
        totalProd += d.production;
        if (d.spei != null && d.spei < DROUGHT_SPEI_THRESHOLD) {
            riskArea += d.harv_area_ha;
            riskProd += d.production;
        }
    }
    document.getElementById('stat-area').textContent = formatHA(totalArea);
    document.getElementById('stat-prod').textContent = formatMT(totalProd);

    const areaPct = totalArea > 0 ? (riskArea / totalArea * 100) : 0;
    const prodPct = totalProd > 0 ? (riskProd / totalProd * 100) : 0;
    document.getElementById('stat-area-risk').textContent = `${formatHA(riskArea)} (${areaPct.toFixed(1)}%)`;
    document.getElementById('stat-risk').textContent = `${formatMT(riskProd)} (${prodPct.toFixed(1)}%)`;
}

// ============================================================
// Legend
// ============================================================

function buildLegend() {
    const container = document.getElementById('h3-legend');

    if (currentView === 'production') {
        container.innerHTML = `
            <div class="h3-legend-title">Production Intensity</div>
            <div class="h3-legend-grid-wrap">
                <div class="h3-quad-ramp" id="prod-ramp"></div>
                <div class="h3-quad-prod-labels"><span>Low</span><span>Production &rarr;</span><span>High</span></div>
            </div>`;
        const el = document.getElementById('prod-ramp');
        for (const [r, g, b] of PROD_RAMP) {
            const cell = document.createElement('div');
            cell.className = 'h3-quad-ramp-cell';
            cell.style.background = `rgb(${r},${g},${b})`;
            el.appendChild(cell);
        }
    } else if (currentView === 'tech-biv') {
        container.innerHTML = `
            <div class="h3-legend-title">Production &times; Irrigated vs Rainfed</div>
            <div class="h3-legend-body">
                <div class="h3-legend-ylabel">Rainfed share &rarr;</div>
                <div class="h3-legend-grid-wrap">
                    <div class="h3-legend-grid" id="h3-legend-grid"></div>
                    <div class="h3-legend-ticks"><span>Low</span><span>Production &rarr;</span><span>High</span></div>
                </div>
            </div>`;
        const grid = document.getElementById('h3-legend-grid');
        const {BL, BR, TL, TR} = TECH_BIV_CORNERS;
        for (let row = 4; row >= 0; row--) {
            const ty = row / 4; // 0 = irrigated (bottom), 1 = rainfed (top)
            for (let col = 0; col < 5; col++) {
                const tx = col / 4; // 0 = low prod, 1 = high prod
                const rgb = [
                    Math.round((1-tx)*(1-ty)*BL[0] + tx*(1-ty)*BR[0] + (1-tx)*ty*TL[0] + tx*ty*TR[0]),
                    Math.round((1-tx)*(1-ty)*BL[1] + tx*(1-ty)*BR[1] + (1-tx)*ty*TL[1] + tx*ty*TR[1]),
                    Math.round((1-tx)*(1-ty)*BL[2] + tx*(1-ty)*BR[2] + (1-tx)*ty*TL[2] + tx*ty*TR[2]),
                ];
                const cell = document.createElement('div');
                cell.className = 'h3-legend-cell';
                cell.style.background = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
                grid.appendChild(cell);
            }
        }
    } else if (currentView === 'quad') {
        const thr = DROUGHT_SPEI_THRESHOLD;
        container.innerHTML = `
            <div class="h3-legend-title">Production &times; Technology &times; Drought</div>
            <div class="h3-quad-legend">
                <div>
                    <div class="h3-quad-zone-label safe">Production (SPEI &ge; ${thr})</div>
                    <div class="h3-quad-ramps">
                        <div class="h3-quad-ramp-wrap">
                            <div class="h3-quad-ramp" id="q-safe-irrig"></div>
                            <div class="h3-quad-ramp-label">Irrigated</div>
                        </div>
                        <div class="h3-quad-ramp-wrap">
                            <div class="h3-quad-ramp" id="q-safe-rain"></div>
                            <div class="h3-quad-ramp-label">Rainfed</div>
                        </div>
                    </div>
                </div>
                <div>
                    <div class="h3-quad-zone-label risk">Drought Zone (SPEI &lt; ${thr})</div>
                    <div class="h3-quad-ramps">
                        <div class="h3-quad-ramp-wrap">
                            <div class="h3-quad-ramp" id="q-drought-irrig"></div>
                            <div class="h3-quad-ramp-label">Irrigated</div>
                        </div>
                        <div class="h3-quad-ramp-wrap">
                            <div class="h3-quad-ramp" id="q-drought-rain"></div>
                            <div class="h3-quad-ramp-label">Rainfed</div>
                        </div>
                    </div>
                </div>
                <div class="h3-quad-prod-labels"><span>Low</span><span>Production &rarr;</span><span>High</span></div>
            </div>`;

        const rampPairs = [
            ['q-safe-irrig', QUAD.safe_irrig], ['q-safe-rain', QUAD.safe_rain],
            ['q-drought-irrig', QUAD.drought_irrig], ['q-drought-rain', QUAD.drought_rain],
        ];
        for (const [id, ramp] of rampPairs) {
            const el = document.getElementById(id);
            for (const [r, g, b] of ramp) {
                const cell = document.createElement('div');
                cell.className = 'h3-quad-ramp-cell';
                cell.style.background = `rgb(${r},${g},${b})`;
                el.appendChild(cell);
            }
        }
    } else {
        // Bivariate 5x5 grid
        const pal = PALETTES[currentPalette];
        container.innerHTML = `
            <div class="h3-legend-title">Production &times; Drought Risk (${pal.name})</div>
            <div class="h3-legend-body">
                <div class="h3-legend-ylabel">Drought risk &rarr;</div>
                <div class="h3-legend-grid-wrap">
                    <div class="h3-legend-grid" id="h3-legend-grid"></div>
                    <div class="h3-legend-ticks"><span>Low</span><span>Production &rarr;</span><span>High</span></div>
                </div>
            </div>`;
        const grid = document.getElementById('h3-legend-grid');
        for (let row = 4; row >= 0; row--) {
            const t = row / 4;
            for (let col = 0; col < 5; col++) {
                const rgb = lerpColor(pal.safe[col], pal.drought[col], t);
                const cell = document.createElement('div');
                cell.className = 'h3-legend-cell';
                cell.style.background = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
                grid.appendChild(cell);
            }
        }
    }
}

// ============================================================
// UI Controls
// ============================================================

function populateControls() {
    const selCrop = document.getElementById('sel-crop');
    for (const c of CROPS) {
        const opt = document.createElement('option');
        opt.value = c.code; opt.textContent = c.name;
        if (c.code === 'whea') opt.selected = true;
        selCrop.appendChild(opt);
    }

    const selPalette = document.getElementById('sel-palette');
    for (const [key, pal] of Object.entries(PALETTES)) {
        const opt = document.createElement('option');
        opt.value = key; opt.textContent = pal.name;
        if (key === currentPalette) opt.selected = true;
        selPalette.appendChild(opt);
    }
    selPalette.addEventListener('change', (e) => {
        currentPalette = e.target.value;
        buildLegend();
        if (currentData.length) buildLayers(currentData);
    });

    document.getElementById('sel-threshold').addEventListener('change', (e) => {
        DROUGHT_SPEI_THRESHOLD = parseFloat(e.target.value);
        buildLegend();
        if (currentData.length) {
            if (currentView === 'quad') buildLayers(currentData);
            updateStats(currentData);
        }
    });

    // View tabs
    for (const tab of document.querySelectorAll('.h3-view-tab')) {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.h3-view-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            currentView = tab.dataset.view;
            updateControlVisibility();
            buildLegend();
            currentData = []; // force re-query (data shape differs)
            refresh();
        });
    }

    function updateControlVisibility() {
        document.getElementById('cg-tech').classList.toggle('dimmed', currentView !== 'production');
        document.getElementById('cg-palette').classList.toggle('dimmed', currentView !== 'bivariate');
    }
    updateControlVisibility();

    let debounceTimer = null;
    function debouncedRefresh() {
        setStatus('Loading...');
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(refresh, 300);
    }
    document.getElementById('sel-crop').addEventListener('change', debouncedRefresh);
    document.getElementById('sel-tech').addEventListener('change', debouncedRefresh);
    document.getElementById('sel-scenario').addEventListener('change', debouncedRefresh);
}

// ============================================================
// Refresh Cycle
// ============================================================

async function refresh() {
    if (queryInFlight) return;
    queryInFlight = true;

    const crop = document.getElementById('sel-crop').value;
    const scenario = document.getElementById('sel-scenario').value;
    currentCropName = CROPS.find(c => c.code === crop)?.name || crop;

    setStatus('Querying...');

    try {
        const t0 = performance.now();
        let result;
        if (currentView === 'production') {
            const tech = document.getElementById('sel-tech').value;
            result = await queryData(crop, tech, scenario);
        } else {
            result = await queryBothTechs(crop, scenario);
        }
        const tQuery = performance.now() - t0;

        setStatus('Filtering region...');
        currentData = filterRegion(result.data);

        const t2 = performance.now();
        buildLayers(currentData);
        const tRender = performance.now() - t2;

        updateStats(currentData);

        const parts = [`${currentData.length.toLocaleString()} hexagons`];
        if (result.fromCache) parts.push('cached');
        else parts.push(`${(tQuery/1000).toFixed(1)}s query`);
        parts.push(`${(tRender/1000).toFixed(1)}s render`);
        setStatus(parts.join(', '));

    } catch (e) {
        console.error('Query error:', e);
        setStatus('Query failed \u2014 see console');
    } finally {
        queryInFlight = false;
    }
}

// ============================================================
// Helpers
// ============================================================

const FONT = '-apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif';

function drawLegendToCanvas(ctx, canvasH) {
    // Position: bottom-left, matching CSS #h3-legend
    const pad = 14;
    const cellSize = 24;
    const gap = 1;

    if (currentView === 'production') {
        // Single horizontal ramp
        const rampW = PROD_RAMP.length * (cellSize + gap) - gap;
        const boxW = rampW + pad * 2 + 4;
        const boxH = 62;
        const bx = 12, by = canvasH - boxH - 32;

        ctx.fillStyle = 'rgba(30, 32, 48, 0.92)';
        ctx.beginPath(); ctx.roundRect(bx, by, boxW, boxH, 10); ctx.fill();

        ctx.font = `600 12px ${FONT}`;
        ctx.fillStyle = '#b0b0b0';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.fillText('Production Intensity', bx + pad, by + pad);

        const ry = by + pad + 18;
        for (let i = 0; i < PROD_RAMP.length; i++) {
            const [r, g, b] = PROD_RAMP[i];
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(bx + pad + i * (cellSize + gap), ry, cellSize, 14);
        }

        ctx.font = `10px ${FONT}`;
        ctx.fillStyle = '#888';
        ctx.textAlign = 'left';
        ctx.fillText('Low', bx + pad, ry + 18);
        ctx.textAlign = 'right';
        ctx.fillText('High', bx + pad + rampW, ry + 18);
        ctx.textAlign = 'left';

    } else if (currentView === 'bivariate' || currentView === 'tech-biv') {
        // 5x5 grid legend
        const gridW = 5 * (cellSize + gap) - gap;
        const boxW = gridW + pad * 2 + 28;  // extra for Y-axis label
        const boxH = gridW + pad * 2 + 36;  // extra for title + X-axis label
        const bx = 12, by = canvasH - boxH - 32;

        ctx.fillStyle = 'rgba(30, 32, 48, 0.92)';
        ctx.beginPath(); ctx.roundRect(bx, by, boxW, boxH, 10); ctx.fill();

        // Title
        const isTech = currentView === 'tech-biv';
        const titleText = isTech
            ? 'Production \u00d7 Irrigated vs Rainfed'
            : `Production \u00d7 Drought Risk (${PALETTES[currentPalette].name})`;
        ctx.font = `600 12px ${FONT}`;
        ctx.fillStyle = '#b0b0b0';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.fillText(titleText, bx + pad, by + pad);

        // Y-axis label (rotated)
        const yLabel = isTech ? 'Rainfed share \u2192' : 'Drought risk \u2192';
        ctx.save();
        ctx.translate(bx + pad + 2, by + pad + 18 + gridW / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.font = `11px ${FONT}`;
        ctx.fillStyle = '#a0a0a0';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(yLabel, 0, 0);
        ctx.restore();

        // Grid
        const gx = bx + pad + 20;
        const gy = by + pad + 18;
        for (let row = 4; row >= 0; row--) {
            const t = row / 4;
            for (let col = 0; col < 5; col++) {
                let rgb;
                if (isTech) {
                    const tx = col / 4, ty = t;
                    const {BL, BR, TL, TR} = TECH_BIV_CORNERS;
                    rgb = [
                        Math.round((1-tx)*(1-ty)*BL[0] + tx*(1-ty)*BR[0] + (1-tx)*ty*TL[0] + tx*ty*TR[0]),
                        Math.round((1-tx)*(1-ty)*BL[1] + tx*(1-ty)*BR[1] + (1-tx)*ty*TL[1] + tx*ty*TR[1]),
                        Math.round((1-tx)*(1-ty)*BL[2] + tx*(1-ty)*BR[2] + (1-tx)*ty*TL[2] + tx*ty*TR[2]),
                    ];
                } else {
                    const pal = PALETTES[currentPalette];
                    rgb = lerpColor(pal.safe[col], pal.drought[col], t);
                }
                ctx.fillStyle = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
                const cx = gx + col * (cellSize + gap);
                const cy = gy + (4 - row) * (cellSize + gap);
                ctx.fillRect(cx, cy, cellSize, cellSize);
            }
        }

        // X-axis labels
        const tickY = gy + 5 * (cellSize + gap) + 2;
        ctx.font = `10px ${FONT}`;
        ctx.fillStyle = '#888';
        ctx.textAlign = 'left';
        ctx.fillText('Low', gx, tickY);
        ctx.textAlign = 'center';
        ctx.fillText('Production \u2192', gx + gridW / 2, tickY);
        ctx.textAlign = 'right';
        ctx.fillText('High', gx + gridW, tickY);
        ctx.textAlign = 'left';

    } else if (currentView === 'quad') {
        // Quad: 2 zones x 2 ramps each
        const rampCellW = 20;
        const rampH = 16;
        const rampW = 5 * (rampCellW + gap) - gap;
        const boxW = rampW * 2 + pad * 2 + 20;
        const boxH = 140;
        const bx = 12, by = canvasH - boxH - 32;

        ctx.fillStyle = 'rgba(30, 32, 48, 0.92)';
        ctx.beginPath(); ctx.roundRect(bx, by, boxW, boxH, 10); ctx.fill();

        ctx.font = `600 12px ${FONT}`;
        ctx.fillStyle = '#b0b0b0';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.fillText('Production \u00d7 Technology \u00d7 Drought', bx + pad, by + pad);

        const thr = DROUGHT_SPEI_THRESHOLD;
        const zones = [
            { label: `Production (SPEI \u2265 ${thr})`, color: '#2ab873', ramps: [
                { label: 'Irrigated', colors: QUAD.safe_irrig },
                { label: 'Rainfed', colors: QUAD.safe_rain },
            ]},
            { label: `Drought Zone (SPEI < ${thr})`, color: '#e63946', ramps: [
                { label: 'Irrigated', colors: QUAD.drought_irrig },
                { label: 'Rainfed', colors: QUAD.drought_rain },
            ]},
        ];

        let zy = by + pad + 20;
        for (const zone of zones) {
            ctx.font = `600 12px ${FONT}`;
            ctx.fillStyle = zone.color;
            ctx.fillText(zone.label, bx + pad, zy);
            zy += 16;

            for (let ri = 0; ri < zone.ramps.length; ri++) {
                const ramp = zone.ramps[ri];
                const rx = bx + pad + ri * (rampW + 12);
                for (let i = 0; i < ramp.colors.length; i++) {
                    const [r, g, b] = ramp.colors[i];
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fillRect(rx + i * (rampCellW + gap), zy, rampCellW, rampH);
                }
                ctx.font = `10px ${FONT}`;
                ctx.fillStyle = '#999';
                ctx.textAlign = 'center';
                ctx.fillText(ramp.label, rx + rampW / 2, zy + rampH + 2);
                ctx.textAlign = 'left';
            }
            zy += rampH + 16;
        }

        // Production axis labels
        ctx.font = `10px ${FONT}`;
        ctx.fillStyle = '#888';
        ctx.fillText('Low', bx + pad, zy);
        ctx.textAlign = 'right';
        ctx.fillText('High', bx + pad + rampW * 2 + 12, zy);
        ctx.textAlign = 'left';
    }
}

// ============================================================
// PNG Export
// ============================================================

function finishExport(canvas, cropName) {
    canvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const date = new Date().toISOString().slice(0, 10);
        a.download = `H3_${cropName.replace(/\s+/g, '_')}_${currentView}_${date}.png`;
        a.href = url;
        a.click();
        URL.revokeObjectURL(url);

        const btn = document.getElementById('btn-export');
        btn.disabled = false;
        btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"><path d="M8 2v8M4.5 7L8 10.5 11.5 7M3 13h10"/></svg> PNG`;
    }, 'image/png');
}

function captureMap() {
    const btn = document.getElementById('btn-export');
    btn.disabled = true;
    btn.textContent = 'Exporting...';

    // Small delay lets the browser finish any pending renders
    requestAnimationFrame(() => { requestAnimationFrame(() => {
        try {
            const container = document.getElementById('h3-map');
            const canvases = container.querySelectorAll('canvas');
            const w = container.offsetWidth;
            const h = container.offsetHeight;
            const dpr = window.devicePixelRatio || 1;

            const out = document.createElement('canvas');
            out.width = w * dpr;
            out.height = h * dpr;
            const ctx = out.getContext('2d');
            ctx.scale(dpr, dpr);

            // Composite all map canvases (MapLibre basemap + deck.gl overlay)
            for (const c of canvases) {
                ctx.drawImage(c, 0, 0, w, h);
            }

            // Stamp info bar at the top
            const crop = document.getElementById('sel-crop');
            const cropName = crop.options[crop.selectedIndex].text;
            const scenario = document.getElementById('sel-scenario');
            const scenarioName = scenario.options[scenario.selectedIndex].text;
            const tech = document.getElementById('sel-tech');
            const techName = tech.options[tech.selectedIndex].text;
            const threshold = document.getElementById('sel-threshold');
            const thresholdName = threshold.options[threshold.selectedIndex].text;

            const title = `${cropName} (${techName}) \u2014 ${scenarioName} \u2014 ${thresholdName}`;

            const barH = 36;
            ctx.fillStyle = 'rgba(10, 10, 20, 0.85)';
            ctx.fillRect(0, 0, w, barH);
            ctx.font = '600 13px -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif';
            ctx.fillStyle = '#d0d0d0';
            ctx.textBaseline = 'middle';
            ctx.fillText(title, 14, barH / 2);

            // Stamp stats at bottom-right
            const stats = [
                ['Harvested Area', document.getElementById('stat-area').textContent],
                ['Area at Risk', document.getElementById('stat-area-risk').textContent],
                ['Production', document.getElementById('stat-prod').textContent],
                ['Prod at Risk', document.getElementById('stat-risk').textContent],
            ];

            const statH = 18;
            const blockH = stats.length * statH + 16;
            const blockW = 280;
            const bx = w - blockW - 12;
            const by = h - blockH - 12;

            ctx.fillStyle = 'rgba(10, 10, 20, 0.82)';
            ctx.roundRect(bx, by, blockW, blockH, 6);
            ctx.fill();

            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif';
            for (let i = 0; i < stats.length; i++) {
                const y = by + 12 + i * statH;
                ctx.fillStyle = '#a0a0a0';
                ctx.textBaseline = 'top';
                ctx.textAlign = 'left';
                ctx.fillText(stats[i][0], bx + 10, y);
                ctx.fillStyle = i % 2 === 1 ? '#c85a5a' : '#d0d0d0';
                ctx.textAlign = 'right';
                ctx.fillText(stats[i][1], bx + blockW - 10, y);
            }
            ctx.textAlign = 'left';

            // Draw legend directly via Canvas 2D (reliable across all browsers)
            drawLegendToCanvas(ctx, h);
            finishExport(out, cropName);

        } catch (e) {
            console.error('Export failed:', e);
            alert('Export failed \u2014 see console');
            btn.disabled = false;
            btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"><path d="M8 2v8M4.5 7L8 10.5 11.5 7M3 13h10"/></svg> PNG`;
        }
    }); });
}

document.getElementById('btn-export').addEventListener('click', captureMap);

// ============================================================

function setLoading(msg) {
    document.getElementById('h3-loading-text').textContent = msg;
    document.getElementById('h3-loading').classList.remove('hidden');
}
function hideLoading() { document.getElementById('h3-loading').classList.add('hidden'); }
function setStatus(msg) { document.getElementById('h3-status').textContent = msg; }

// ============================================================
// Main
// ============================================================

(async function main() {
    if (!SERVER_SIDE) {
        setLoading('{{ name }} Explorer requires server-side DuckDB (ENABLE_H3_DUCKDB=true).');
        return;
    }
    try {
        setLoading('Loading map & boundaries...');
        initMap();
        populateControls();

        await Promise.all([
            loadBoundaries(),
            new Promise(resolve => {
                if (map.isStyleLoaded()) resolve();
                else map.on('load', resolve);
            }),
        ]);

        buildLegend();
        hideLoading();
        await refresh();

    } catch (e) {
        console.error('Initialization failed:', e);
        setLoading('Failed to initialize \u2014 see console');
    }
})();

</script>
</body>
</html>
