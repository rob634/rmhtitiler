{% extends "base.html" %}

{% block title %}H3 Crop Production & Drought Risk Explorer{% endblock %}

{% block main_class %}h3-explorer{% endblock %}

{% block head %}
<!-- MapLibre GL JS -->
<link href="https://unpkg.com/maplibre-gl@^4.0.0/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@^4.0.0/dist/maplibre-gl.js"></script>

<!-- deck.gl standalone -->
<script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"></script>

<!-- h3-js for hex geometry conversion -->
<script src="https://unpkg.com/h3-js@^4.0.0/dist/h3-js.umd.js"></script>

<style>
/* ---- Full-viewport dark layout ---- */
.h3-explorer {
    position: relative;
    height: calc(100vh - 50px);
    padding: 0;
    max-width: none;
    background: #0a0a14;
    color: #d0d0d0;
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
}

#h3-map { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

/* ---- Controls ---- */
#h3-controls {
    position: absolute; top: 12px; left: 12px; z-index: 10;
    background: rgba(12, 12, 22, 0.88); backdrop-filter: blur(16px);
    border: 1px solid rgba(255,255,255,0.07); border-radius: 10px;
    padding: 14px 18px; display: flex; gap: 14px; align-items: flex-end; flex-wrap: wrap;
    max-width: calc(100vw - 24px);
}
.h3-cg { display: flex; flex-direction: column; gap: 3px; }
.h3-cg label {
    font-size: 9px; text-transform: uppercase; letter-spacing: 0.8px;
    color: #777; font-weight: 600;
}
.h3-cg select {
    background: rgba(255,255,255,0.06); color: #e0e0e0;
    border: 1px solid rgba(255,255,255,0.12); border-radius: 6px;
    padding: 6px 28px 6px 10px; font-size: 13px; cursor: pointer;
    appearance: none; -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23888'/%3E%3C/svg%3E");
    background-repeat: no-repeat; background-position: right 8px center;
}
.h3-cg select:hover { border-color: rgba(255,255,255,0.25); }
.h3-cg select:focus { outline: none; border-color: #64acbe; }

/* ---- View Tabs ---- */
.h3-view-tabs {
    display: flex; gap: 2px; background: rgba(255,255,255,0.04);
    border-radius: 6px; padding: 2px; align-self: flex-end;
}
.h3-view-tab {
    background: none; border: none; color: #777; font-size: 11px; font-weight: 600;
    padding: 6px 12px; border-radius: 5px; cursor: pointer; white-space: nowrap;
    transition: all 0.15s;
}
.h3-view-tab:hover { color: #bbb; }
.h3-view-tab.active { background: rgba(255,255,255,0.1); color: #e0e0e0; }

#h3-status {
    font-size: 11px; color: #888; padding: 6px 0; min-width: 120px; text-align: right;
}

/* ---- Legend ---- */
#h3-legend {
    position: absolute; bottom: 32px; left: 12px; z-index: 10;
    background: rgba(12, 12, 22, 0.88); backdrop-filter: blur(16px);
    border: 1px solid rgba(255,255,255,0.07); border-radius: 10px;
    padding: 14px 16px;
}
.h3-legend-title { font-size: 11px; font-weight: 600; margin-bottom: 8px; color: #aaa; }
.h3-legend-body { display: flex; gap: 6px; align-items: flex-end; }
.h3-legend-ylabel {
    writing-mode: vertical-lr; transform: rotate(180deg);
    font-size: 9px; color: #888; text-align: center; letter-spacing: 0.5px;
}
.h3-legend-grid-wrap { display: flex; flex-direction: column; align-items: center; }
.h3-legend-grid {
    display: grid; grid-template-columns: repeat(3, 28px); grid-template-rows: repeat(3, 28px);
    gap: 2px;
}
.h3-legend-cell { border-radius: 3px; }
.h3-legend-xlabel { font-size: 9px; color: #888; margin-top: 4px; letter-spacing: 0.5px; }
.h3-legend-ticks { display: flex; justify-content: space-between; width: 100%; }
.h3-legend-ticks span { font-size: 8px; color: #666; }

/* ---- Segmented Legend ---- */
.h3-seg-legend { display: flex; flex-direction: column; gap: 10px; }
.h3-seg-row-label { font-size: 10px; font-weight: 600; margin-bottom: 3px; }
.h3-seg-row-label.safe { color: #d4a017; }
.h3-seg-row-label.risk { color: #e63946; }
.h3-seg-ramp {
    display: flex; gap: 1px; height: 16px; border-radius: 3px; overflow: hidden;
}
.h3-seg-ramp-cell { flex: 1; }
.h3-seg-ramp-labels { display: flex; justify-content: space-between; margin-top: 2px; }
.h3-seg-ramp-labels span { font-size: 8px; color: #666; }

/* ---- Stats ---- */
#h3-stats {
    position: absolute; bottom: 32px; right: 12px; z-index: 10;
    background: rgba(12, 12, 22, 0.88); backdrop-filter: blur(16px);
    border: 1px solid rgba(255,255,255,0.07); border-radius: 10px;
    padding: 12px 16px; min-width: 180px;
}
.h3-stat-row { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 4px; }
.h3-stat-label { font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }
.h3-stat-value { font-size: 13px; font-weight: 600; font-variant-numeric: tabular-nums; }
.h3-stat-value.warning { color: #c85a5a; }

/* ---- Tooltip ---- */
#h3-tooltip {
    display: none; position: absolute; z-index: 20; pointer-events: none;
    background: rgba(8, 8, 16, 0.92); backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;
    padding: 10px 14px; font-size: 12px; line-height: 1.5;
    max-width: 260px; color: #d0d0d0;
}
#h3-tooltip strong { color: #fff; }
#h3-tooltip .val { color: #64acbe; font-weight: 600; }
#h3-tooltip .spei-val { font-weight: 600; }
.spei-wet { color: #64acbe; }
.spei-mod { color: #e4acac; }
.spei-dry { color: #c85a5a; }

/* ---- Loading ---- */
#h3-loading {
    position: absolute; inset: 0; z-index: 100;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: rgba(6, 6, 14, 0.95); transition: opacity 0.3s;
}
#h3-loading.hidden { opacity: 0; pointer-events: none; }
.h3-spinner {
    width: 36px; height: 36px; border: 3px solid rgba(255,255,255,0.1);
    border-top-color: #64acbe; border-radius: 50%;
    animation: h3spin 0.8s linear infinite; margin-bottom: 12px;
}
@keyframes h3spin { to { transform: rotate(360deg); } }
.h3-loading-text { font-size: 13px; color: #888; }

/* ---- MapLibre overrides (scoped) ---- */
.h3-explorer .maplibregl-popup-content {
    background: rgba(12, 12, 22, 0.94) !important; color: #d0d0d0 !important;
    border-radius: 8px !important; padding: 12px 16px !important; font-size: 12px;
    border: 1px solid rgba(255,255,255,0.1);
}
.h3-explorer .maplibregl-popup-tip { border-top-color: rgba(12, 12, 22, 0.94) !important; }
.h3-explorer .maplibregl-popup-close-button { color: #888 !important; font-size: 16px; }
.h3-explorer .maplibregl-ctrl-attrib { font-size: 10px !important; }
</style>
{% endblock %}

{% block content %}
<div id="h3-map"></div>

<div id="h3-controls">
    <div class="h3-cg">
        <label>Crop</label>
        <select id="sel-crop"></select>
    </div>
    <div class="h3-cg">
        <label>Technology</label>
        <select id="sel-tech">
            <option value="a">All</option>
            <option value="i">Irrigated</option>
            <option value="r">Rainfed</option>
        </select>
    </div>
    <div class="h3-cg">
        <label>Climate Scenario</label>
        <select id="sel-scenario">
            <option value="spei12_hist_median">Historical &mdash; Median</option>
            <option value="spei12_hist_p10">Historical &mdash; P10 (Dry)</option>
            <option value="spei12_ssp370_median">SSP3-7.0 &mdash; Median</option>
            <option value="spei12_ssp370_p10">SSP3-7.0 &mdash; P10 (Dry)</option>
            <option value="spei12_ssp585_median" selected>SSP5-8.5 &mdash; Median</option>
            <option value="spei12_ssp585_p10">SSP5-8.5 &mdash; P10 (Dry)</option>
        </select>
    </div>
    <div class="h3-cg">
        <label>Drought Threshold</label>
        <select id="sel-threshold">
            <option value="-1">SPEI &lt; -1.0 (Moderate)</option>
            <option value="-1.5" selected>SPEI &lt; -1.5 (Severe)</option>
            <option value="-2">SPEI &lt; -2.0 (Extreme)</option>
        </select>
    </div>
    <div class="h3-cg">
        <label>Palette</label>
        <select id="sel-palette"></select>
    </div>
    <div class="h3-cg">
        <label>View</label>
        <div class="h3-view-tabs">
            <button class="h3-view-tab active" data-view="bivariate">Bivariate</button>
            <button class="h3-view-tab" data-view="segmented">Risk Segmented</button>
        </div>
    </div>
    <div id="h3-status">Initializing...</div>
</div>

<div id="h3-legend"></div>

<div id="h3-stats">
    <div class="h3-stat-row">
        <span class="h3-stat-label">Hexagons</span>
        <span class="h3-stat-value" id="stat-hexes">-</span>
    </div>
    <div class="h3-stat-row">
        <span class="h3-stat-label">Total Production</span>
        <span class="h3-stat-value" id="stat-prod">-</span>
    </div>
    <div class="h3-stat-row">
        <span class="h3-stat-label" id="stat-risk-label">At Drought Risk</span>
        <span class="h3-stat-value warning" id="stat-risk">-</span>
    </div>
</div>

<div id="h3-tooltip"></div>

<div id="h3-loading">
    <div class="h3-spinner"></div>
    <div class="h3-loading-text" id="h3-loading-text">Initializing...</div>
</div>
{% endblock %}

{% block scripts %}
<script type="module">

// ============================================================
// Configuration
// ============================================================

const PARQUET_URL = '{{ h3_parquet_url }}';
const STORAGE_TOKEN = '{{ h3_storage_token }}';
const AUTH_ENABLED = {{ 'true' if h3_auth_enabled else 'false' }};
const TOKEN_REFRESH_MS = 30 * 60 * 1000;  // 30 minutes
const SERVER_SIDE = {{ 'true' if h3_server_side else 'false' }};

const CROPS = [
    {code:'bana',name:'Banana'},{code:'barl',name:'Barley'},{code:'bean',name:'Bean'},
    {code:'cass',name:'Cassava'},{code:'chic',name:'Chickpea'},{code:'citr',name:'Citrus'},
    {code:'cnut',name:'Coconut'},{code:'coco',name:'Cocoa'},{code:'coff',name:'Arabica Coffee'},
    {code:'cott',name:'Cotton'},{code:'cowp',name:'Cowpea'},{code:'grou',name:'Groundnut'},
    {code:'lent',name:'Lentil'},{code:'maiz',name:'Maize'},{code:'mill',name:'Millet (Small)'},
    {code:'ocer',name:'Other Cereals'},{code:'ofib',name:'Other Fibre'},{code:'oilp',name:'Oil Palm'},
    {code:'onio',name:'Onion'},{code:'ooil',name:'Other Oils'},{code:'opul',name:'Other Pulses'},
    {code:'orts',name:'Other Roots'},{code:'pige',name:'Pigeonpea'},{code:'plnt',name:'Plantain'},
    {code:'pmil',name:'Pearl Millet'},{code:'pota',name:'Potato'},{code:'rape',name:'Rapeseed'},
    {code:'rcof',name:'Robusta Coffee'},{code:'rest',name:'Rest of Crops'},{code:'rice',name:'Rice'},
    {code:'rubb',name:'Rubber'},{code:'sesa',name:'Sesame'},{code:'sorg',name:'Sorghum'},
    {code:'soyb',name:'Soybean'},{code:'sugb',name:'Sugar Beet'},{code:'sugc',name:'Sugarcane'},
    {code:'sunf',name:'Sunflower'},{code:'swpo',name:'Sweet Potato'},{code:'teas',name:'Tea'},
    {code:'temf',name:'Temperate Fruit'},{code:'toba',name:'Tobacco'},{code:'toma',name:'Tomato'},
    {code:'trof',name:'Tropical Fruit'},{code:'vege',name:'Vegetables'},{code:'whea',name:'Wheat'},
    {code:'yams',name:'Yams'},
];

// Bivariate palettes: colors[drought_row][prod_col], safe/drought ramps
const PALETTES = {
    stevens: {
        name: 'Classic (Stevens)',
        colors: [
            [[232,232,232], [176,213,223], [100,172,190]],
            [[228,172,172], [173,158,165], [98,127,140]],
            [[200,90,90],   [152,83,86],   [87,66,73]],
        ],
        safe:    [[255,255,212], [254,227,145], [254,196,79], [217,160,40], [153,107,15]],
        drought: [[254,210,200], [252,154,120], [239,83,80], [203,24,29], [128,0,13]],
    },
    fire: {
        name: 'Fire Alert',
        colors: [
            [[230,230,230], [166,218,208], [60,180,150]],
            [[240,170,160], [190,155,148], [100,130,110]],
            [[255,65,54],   [230,50,90],   [255,0,80]],
        ],
        safe:    [[240,248,240], [180,225,200], [100,200,155], [40,175,115], [0,140,80]],
        drought: [[255,210,200], [255,145,120], [255,70,60],   [230,20,40],  [180,0,30]],
    },
    neon: {
        name: 'Neon Danger',
        colors: [
            [[235,235,235], [180,215,220], [80,180,195]],
            [[245,195,140], [200,175,145], [130,150,140]],
            [[255,140,0],   [255,100,30],  [255,200,0]],
        ],
        safe:    [[240,245,250], [185,220,230], [110,195,210], [50,170,190], [0,140,165]],
        drought: [[255,230,180], [255,190,100], [255,155,30],  [255,120,0],  [230,90,0]],
    },
    emergency: {
        name: 'Emergency Red',
        colors: [
            [[225,228,232], [170,190,210], [90,140,180]],
            [[230,180,175], [185,160,170], [120,125,150]],
            [[220,50,47],   [200,40,70],   [235,30,35]],
        ],
        safe:    [[230,235,245], [180,200,225], [120,160,200], [70,125,180], [30,90,155]],
        drought: [[250,210,200], [245,160,140], [235,100,85],  [220,50,40],  [180,20,20]],
    },
    violet: {
        name: 'Violet Heat',
        colors: [
            [[230,232,228], [175,215,195], [80,185,140]],
            [[225,180,210], [180,160,180], [105,135,140]],
            [[200,50,160],  [180,30,180],  [230,0,255]],
        ],
        safe:    [[235,245,235], [180,225,195], [110,200,150], [50,175,110], [10,145,75]],
        drought: [[240,200,230], [225,140,200], [210,80,175],  [195,30,155], [170,0,130]],
    },
    solar: {
        name: 'Solar Flare',
        colors: [
            [[228,232,238], [185,205,218], [120,170,195]],
            [[242,200,175], [210,178,168], [155,150,148]],
            [[240,80,40],   [245,110,50],  [255,160,0]],
        ],
        safe:    [[235,240,248], [190,210,230], [135,180,210], [85,150,190], [40,115,168]],
        drought: [[255,225,195], [255,180,120], [255,130,55],  [245,85,25],  [220,55,0]],
    },
    stoplight: {
        name: 'Stoplight',
        colors: [
            [[228,232,228], [190,220,190], [50,180,60]],
            [[245,220,150], [215,200,140], [150,175,100]],
            [[235,50,40],   [220,80,50],   [255,180,0]],
        ],
        safe:    [[235,245,235], [195,230,195], [140,210,140], [80,185,80], [30,155,35]],
        drought: [[255,235,195], [255,200,120], [255,155,50],  [240,90,30], [215,40,15]],
    },
};

let currentPalette = 'emergency';

const SPEI_THRESHOLDS = [0, -1];
let DROUGHT_SPEI_THRESHOLD = -1.5;

// ============================================================
// State
// ============================================================

let db = null;
let conn = null;
let map = null;
let deckOverlay = null;
let currentData = [];
let queryInFlight = false;
let currentCropName = 'Wheat';
let currentView = 'bivariate';
const queryCache = new Map();  // Client-side cache: "crop_tech_scenario" → data array

// ============================================================
// DuckDB-WASM
// ============================================================

async function initDuckDB() {
    setLoading('Loading query engine...');
    const duckdb = await import('https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm/+esm');
    const bundles = duckdb.getJsDelivrBundles();
    const bundle = await duckdb.selectBundle(bundles);

    const workerUrl = URL.createObjectURL(
        new Blob([`importScripts("${bundle.mainWorker}");`], {type: 'text/javascript'})
    );
    const worker = new Worker(workerUrl);
    const logger = new duckdb.ConsoleLogger(duckdb.LogLevel.WARNING);
    db = new duckdb.AsyncDuckDB(logger, worker);
    await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
    URL.revokeObjectURL(workerUrl);

    conn = await db.connect();

    // Configure bearer token for authenticated Azure Blob Storage access.
    // The server passes its cached OAuth token (same one GDAL uses);
    // DuckDB-WASM attaches it as an Authorization header on range requests.
    if (AUTH_ENABLED && STORAGE_TOKEN) {
        await conn.query(`
            CREATE SECRET h3_storage (
                TYPE HTTP,
                BEARER_TOKEN '${STORAGE_TOKEN}'
            );
        `);
        console.log('DuckDB storage auth configured');

        // Refresh token every 30 minutes (tokens expire after ~60 min)
        setInterval(async () => {
            try {
                const resp = await fetch('/h3/token');
                const data = await resp.json();
                if (data.token) {
                    await conn.query(`DROP SECRET IF EXISTS h3_storage;`);
                    await conn.query(`
                        CREATE SECRET h3_storage (
                            TYPE HTTP,
                            BEARER_TOKEN '${data.token}'
                        );
                    `);
                    console.log('DuckDB storage token refreshed');
                }
            } catch (e) {
                console.warn('Token refresh failed:', e);
            }
        }, TOKEN_REFRESH_MS);
    }

    setLoading('Connecting to dataset...');
    try {
        const probe = await conn.query(
            `SELECT count(*) as n FROM '${PARQUET_URL}' LIMIT 1`
        );
        const n = probe.toArray()[0].n;
        console.log(`Dataset connected: ${Number(n).toLocaleString()} hexagons`);
    } catch (e) {
        console.error('Failed to connect to parquet:', e);
        setLoading('Error: Could not load data. Check CORS/blob access.');
        throw e;
    }
}

async function queryData(crop, tech, scenario) {
    const cacheKey = `${crop}_${tech}_${scenario}`;

    // Client-side cache check
    const cached = queryCache.get(cacheKey);
    if (cached) return { data: cached, fromCache: true };

    // Server-side: fetch from /h3/query endpoint
    if (SERVER_SIDE) {
        const params = new URLSearchParams({crop, tech, scenario});
        const resp = await fetch(`/h3/query?${params}`);
        if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(err.error || `Query failed (${resp.status})`);
        }
        const result = await resp.json();
        queryCache.set(cacheKey, result.data);
        return { data: result.data, fromCache: false };
    }

    // Browser-side fallback: DuckDB-WASM direct query
    const prodCol = `${crop}_${tech}_production_mt`;
    const sql = `
        SELECT h3_index, "${prodCol}" as production, "${scenario}" as spei
        FROM '${PARQUET_URL}'
        WHERE "${prodCol}" > 0 AND "${prodCol}" IS NOT NULL
    `;

    const result = await conn.query(sql);
    const rows = result.toArray();

    const data = new Array(rows.length);
    for (let i = 0; i < rows.length; i++) {
        const r = rows[i];
        data[i] = {
            h3_index: r.h3_index,
            production: Number(r.production) || 0,
            spei: r.spei != null ? Number(r.spei) : null,
        };
    }
    queryCache.set(cacheKey, data);
    return { data, fromCache: false };
}

// ============================================================
// Bivariate Classification
// ============================================================

function quantileBreaks(values, nBins) {
    const sorted = Float64Array.from(values).sort();
    const breaks = [];
    for (let i = 1; i < nBins; i++) {
        const idx = Math.floor(i * sorted.length / nBins);
        breaks.push(sorted[Math.min(idx, sorted.length - 1)]);
    }
    return breaks;
}

function classifyProd(val, breaks) {
    if (val <= breaks[0]) return 0;
    if (val <= breaks[1]) return 1;
    return 2;
}

function classifyDrought(spei) {
    if (spei == null) return 1;
    if (spei > SPEI_THRESHOLDS[0]) return 0;
    if (spei >= SPEI_THRESHOLDS[1]) return 1;
    return 2;
}

function getColor(prodBin, droughtBin) {
    return [...PALETTES[currentPalette].colors[droughtBin][prodBin], 190];
}

function classifyRamp(val, breaks) {
    for (let i = 0; i < breaks.length; i++) {
        if (val <= breaks[i]) return i;
    }
    return breaks.length;
}

// ============================================================
// Map Initialization
// ============================================================

function initMap() {
    map = new maplibregl.Map({
        container: 'h3-map',
        style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
        center: [20, 15],
        zoom: 2.5,
        maxZoom: 14,
        antialias: true,
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-right');
    map.addControl(new maplibregl.ScaleControl({maxWidth: 150}), 'bottom-right');

    deckOverlay = new deck.MapboxOverlay({interleaved: false, layers: []});
    map.addControl(deckOverlay);
}

// ============================================================
// Hex Rendering
// ============================================================

function buildLayer(data) {
    if (!data.length) {
        deckOverlay.setProps({layers: []});
        return;
    }

    const prodValues = data.map(d => d.production).filter(v => v > 0);

    const processed = new Array(data.length);
    for (let i = 0; i < data.length; i++) {
        const d = data[i];
        const boundary = h3.cellToBoundary(d.h3_index);
        const polygon = boundary.map(([lat, lng]) => [lng, lat]);
        polygon.push(polygon[0]);
        processed[i] = {
            polygon, h3_index: d.h3_index,
            production: d.production, spei: d.spei,
        };
    }

    if (currentView === 'bivariate') {
        const breaks = quantileBreaks(prodValues, 3);
        for (let i = 0; i < processed.length; i++) {
            const p = processed[i];
            p.prodBin = classifyProd(p.production, breaks);
            p.droughtBin = classifyDrought(p.spei);
            p.color = getColor(p.prodBin, p.droughtBin);
            p.isDrought = p.spei != null && p.spei < DROUGHT_SPEI_THRESHOLD;
        }
    } else {
        const breaks = quantileBreaks(prodValues, 5);
        for (let i = 0; i < processed.length; i++) {
            const p = processed[i];
            p.isDrought = p.spei != null && p.spei < DROUGHT_SPEI_THRESHOLD;
            const bin = classifyRamp(p.production, breaks);
            const pal = PALETTES[currentPalette];
            const ramp = p.isDrought ? pal.drought : pal.safe;
            p.color = [...ramp[bin], 200];
            p.prodBin = bin;
            p.droughtBin = p.isDrought ? 1 : 0;
        }
    }

    const layer = new deck.PolygonLayer({
        id: 'h3-layer',
        data: processed,
        getPolygon: d => d.polygon,
        getFillColor: d => d.color,
        getLineColor: [255, 255, 255, 20],
        getLineWidth: 1,
        lineWidthMinPixels: 0.3,
        lineWidthMaxPixels: 1,
        pickable: true,
        autoHighlight: true,
        highlightColor: [255, 255, 255, 60],
        onHover: onHover,
        onClick: onClick,
        parameters: {depthTest: false},
        transitions: {getFillColor: 400},
    });

    deckOverlay.setProps({layers: [layer]});
}

// ============================================================
// Tooltip & Popup
// ============================================================

const tooltip = document.getElementById('h3-tooltip');

function onHover({object, x, y}) {
    if (!object) {
        tooltip.style.display = 'none';
        return;
    }
    const speiClass = object.spei == null ? '' :
        object.spei > 0 ? 'spei-wet' : object.spei >= -1 ? 'spei-mod' : 'spei-dry';
    const speiLabel = object.spei == null ? 'N/A' : object.spei.toFixed(2);

    let riskLabel;
    if (currentView === 'segmented') {
        riskLabel = object.isDrought
            ? '<span style="color:#e63946;font-weight:600">Drought Zone</span> (SPEI &lt; -1.5)'
            : '<span style="color:#d4a017;font-weight:600">Safe Zone</span>';
    } else {
        const droughtLabel = ['Safe', 'Moderate', 'At Risk'][object.droughtBin];
        riskLabel = `<span class="spei-val ${speiClass}">${speiLabel}</span> <span style="color:#888">(${droughtLabel})</span>`;
    }

    tooltip.innerHTML = `
        <strong>${currentCropName}</strong><br>
        Production: <span class="val">${formatMT(object.production)}</span><br>
        SPEI-12: ${riskLabel}
    `;
    tooltip.style.display = 'block';
    tooltip.style.left = `${x + 14}px`;
    tooltip.style.top = `${y + 14}px`;
}

function onClick({object, coordinate}) {
    if (!object || !coordinate) return;
    const speiClass = object.spei == null ? '' :
        object.spei > 0 ? 'spei-wet' : object.spei >= -1 ? 'spei-mod' : 'spei-dry';
    const zoneHtml = object.isDrought
        ? '<span style="color:#e63946;font-weight:600">Drought Zone</span>'
        : '<span style="color:#d4a017;font-weight:600">Safe Zone</span>';
    new maplibregl.Popup({maxWidth: '280px'})
        .setLngLat(coordinate)
        .setHTML(`
            <div style="line-height:1.6">
                <strong style="color:#fff">${currentCropName}</strong><br>
                <span style="color:#888">H3:</span> <code style="font-size:10px">${object.h3_index}</code><br>
                <span style="color:#888">Production:</span> <strong class="val">${formatMT(object.production)}</strong><br>
                <span style="color:#888">SPEI-12:</span> <strong class="spei-val ${speiClass}">${object.spei?.toFixed(3) ?? 'N/A'}</strong><br>
                <span style="color:#888">Zone:</span> ${zoneHtml}
            </div>
        `)
        .addTo(map);
}

function formatMT(val) {
    if (val >= 1e6) return (val / 1e6).toFixed(1) + ' M MT';
    if (val >= 1e3) return (val / 1e3).toFixed(1) + ' K MT';
    return val.toFixed(0) + ' MT';
}

// ============================================================
// Stats Panel
// ============================================================

function updateStats(data) {
    const nHex = data.length;
    const totalProd = data.reduce((s, d) => s + d.production, 0);
    const threshold = currentView === 'segmented' ? DROUGHT_SPEI_THRESHOLD : -1;
    const atRisk = data.filter(d => d.spei != null && d.spei < threshold);
    const riskProd = atRisk.reduce((s, d) => s + d.production, 0);
    const riskPct = totalProd > 0 ? (riskProd / totalProd * 100) : 0;

    document.getElementById('stat-hexes').textContent = nHex.toLocaleString();
    document.getElementById('stat-prod').textContent = formatMT(totalProd);
    document.getElementById('stat-risk').textContent =
        `${formatMT(riskProd)} (${riskPct.toFixed(1)}%)`;
    document.getElementById('stat-risk-label').textContent =
        currentView === 'segmented' ? 'In Drought Zone' : 'At Drought Risk';
}

// ============================================================
// Legend
// ============================================================

function buildLegend() {
    const container = document.getElementById('h3-legend');
    if (currentView === 'bivariate') {
        container.innerHTML = `
            <div class="h3-legend-title">Production x Drought Risk</div>
            <div class="h3-legend-body">
                <div class="h3-legend-ylabel">Drought risk &rarr;</div>
                <div class="h3-legend-grid-wrap">
                    <div class="h3-legend-grid" id="h3-legend-grid"></div>
                    <div class="h3-legend-xlabel">Production &rarr;</div>
                </div>
            </div>`;
        const grid = document.getElementById('h3-legend-grid');
        const pal = PALETTES[currentPalette];
        for (let d = 2; d >= 0; d--) {
            for (let p = 0; p <= 2; p++) {
                const cell = document.createElement('div');
                cell.className = 'h3-legend-cell';
                const [r, g, b] = pal.colors[d][p];
                cell.style.background = `rgb(${r},${g},${b})`;
                cell.title = `${['Low','Med','High'][p]} production, ${['Safe','Moderate','Drought'][d]} risk`;
                grid.appendChild(cell);
            }
        }
    } else {
        container.innerHTML = `
            <div class="h3-legend-title">Production by Drought Zone (SPEI &lt; -1.5)</div>
            <div class="h3-seg-legend">
                <div>
                    <div class="h3-seg-row-label safe">Safe Zone (SPEI &ge; -1.5)</div>
                    <div class="h3-seg-ramp" id="h3-seg-safe-ramp"></div>
                    <div class="h3-seg-ramp-labels"><span>Low</span><span>Production</span><span>High</span></div>
                </div>
                <div>
                    <div class="h3-seg-row-label risk">Drought Zone (SPEI &lt; -1.5)</div>
                    <div class="h3-seg-ramp" id="h3-seg-drought-ramp"></div>
                    <div class="h3-seg-ramp-labels"><span>Low</span><span>Production</span><span>High</span></div>
                </div>
            </div>`;
        const segPal = PALETTES[currentPalette];
        for (const [id, ramp] of [['h3-seg-safe-ramp', segPal.safe], ['h3-seg-drought-ramp', segPal.drought]]) {
            const el = document.getElementById(id);
            for (const [r, g, b] of ramp) {
                const cell = document.createElement('div');
                cell.className = 'h3-seg-ramp-cell';
                cell.style.background = `rgb(${r},${g},${b})`;
                el.appendChild(cell);
            }
        }
    }
}

// ============================================================
// UI Controls
// ============================================================

function populateControls() {
    const sel = document.getElementById('sel-crop');
    for (const c of CROPS) {
        const opt = document.createElement('option');
        opt.value = c.code;
        opt.textContent = c.name;
        if (c.code === 'whea') opt.selected = true;
        sel.appendChild(opt);
    }

    // Palette selector
    const palSel = document.getElementById('sel-palette');
    for (const [key, pal] of Object.entries(PALETTES)) {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = pal.name;
        if (key === currentPalette) opt.selected = true;
        palSel.appendChild(opt);
    }
    palSel.addEventListener('change', () => {
        currentPalette = palSel.value;
        buildLegend();
        if (currentData.length) {
            buildLayer(currentData);
            updateStats(currentData);
        }
    });

    // Drought threshold selector — re-renders existing data, no new query
    document.getElementById('sel-threshold').addEventListener('change', (e) => {
        DROUGHT_SPEI_THRESHOLD = parseFloat(e.target.value);
        buildLegend();
        if (currentData.length) {
            buildLayer(currentData);
            updateStats(currentData);
        }
    });

    let debounceTimer = null;
    function debouncedRefresh() {
        setStatus('Loading...');
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(refresh, 300);
    }
    document.getElementById('sel-crop').addEventListener('change', debouncedRefresh);
    document.getElementById('sel-tech').addEventListener('change', debouncedRefresh);
    document.getElementById('sel-scenario').addEventListener('change', debouncedRefresh);

    for (const tab of document.querySelectorAll('.h3-view-tab')) {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.h3-view-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            currentView = tab.dataset.view;
            buildLegend();
            if (currentData.length) {
                buildLayer(currentData);
                updateStats(currentData);
            }
        });
    }
}

// ============================================================
// Refresh Cycle
// ============================================================

async function refresh() {
    if (queryInFlight) return;
    queryInFlight = true;

    const crop = document.getElementById('sel-crop').value;
    const tech = document.getElementById('sel-tech').value;
    const scenario = document.getElementById('sel-scenario').value;
    currentCropName = CROPS.find(c => c.code === crop)?.name || crop;

    setStatus('Querying...');

    try {
        const t0 = performance.now();
        const { data, fromCache } = await queryData(crop, tech, scenario);
        currentData = data;
        const tQuery = performance.now() - t0;

        const t1 = performance.now();
        buildLayer(currentData);
        const tRender = performance.now() - t1;

        updateStats(currentData);
        if (fromCache) {
            setStatus(`${currentData.length.toLocaleString()} hexagons (cached, ${(tRender/1000).toFixed(1)}s render)`);
        } else {
            setStatus(`${currentData.length.toLocaleString()} hexagons (${(tQuery/1000).toFixed(1)}s query, ${(tRender/1000).toFixed(1)}s render)`);
        }
    } catch (e) {
        console.error('Query error:', e);
        setStatus('Query failed — see console');
    } finally {
        queryInFlight = false;
    }
}

// ============================================================
// Loading / Status Helpers
// ============================================================

function setLoading(msg) {
    document.getElementById('h3-loading-text').textContent = msg;
    document.getElementById('h3-loading').classList.remove('hidden');
}
function hideLoading() { document.getElementById('h3-loading').classList.add('hidden'); }
function setStatus(msg) { document.getElementById('h3-status').textContent = msg; }

// ============================================================
// Main
// ============================================================

(async function main() {
    if (!PARQUET_URL && !SERVER_SIDE) {
        setLoading('H3 Explorer is not configured. Set H3_PARQUET_URL environment variable.');
        return;
    }
    try {
        setLoading('Initializing map...');
        initMap();
        buildLegend();

        if (SERVER_SIDE) {
            // Server-side DuckDB — no WASM download, no token setup
            console.log('Using server-side DuckDB query engine');
        } else {
            // Browser-side fallback — init DuckDB-WASM
            await initDuckDB();
        }

        populateControls();
        hideLoading();

        if (map.isStyleLoaded()) {
            await refresh();
        } else {
            map.on('load', () => refresh());
        }
    } catch (e) {
        console.error('Initialization failed:', e);
    }
})();

</script>
{% endblock %}
